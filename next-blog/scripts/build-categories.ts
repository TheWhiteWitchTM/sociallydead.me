// scripts/build-categories-meta.ts
import fs from 'node:fs/promises';
import path from 'node:path';

const BLOG_ROOT = path.join(process.cwd(), '/blog');

// â”€â”€ CONFIGURABLE PART â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BLOG_URL_PREFIX = '/blog';
const META_OUTPUT_DIR = path.join(process.cwd(), 'next-blog/meta');
const OUTPUT = path.join(META_OUTPUT_DIR, 'categories-meta.ts');
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const DEFAULT_EMOJI = 'ðŸ“';

interface CategoryMeta {
	slug: string;
	title: string;
	description: string;
	date: string;
	path: string;
	url?: string;
	urlType?: string;
	emoji: string;
	pinned: boolean;
	featured: boolean;
	tags: string[];
	posts: number;
	latest: string;
}

async function run() {
	await fs.mkdir(META_OUTPUT_DIR, { recursive: true });

	const categories: CategoryMeta[] = [];

	const entries = await fs.readdir(BLOG_ROOT, { withFileTypes: true });

	for (const entry of entries) {
		if (!entry.isDirectory()) continue;
		if (entry.name.startsWith('(') || entry.name.startsWith('[') || entry.name === 'meta') continue;

		const catFolder = path.join(BLOG_ROOT, entry.name);
		const metaPath = path.join(catFolder, 'meta.ts');

		let rawMeta: any = {};
		try {
			const imported = require(metaPath);
			rawMeta = imported.categoryMeta ||
				imported.meta ||
				imported.categories ||
				imported.default ||
				{};
		} catch {
			console.warn(`No valid meta.ts in ${entry.name} â€” using defaults`);
		}

		const items = Array.isArray(rawMeta) ? rawMeta : [rawMeta];

		for (const item of items) {
			if (!item || typeof item !== 'object') continue;

			const slug = item.slug || entry.name;

			let postCount = 0;
			let latestPostDate = '1900-01-01';
			let earliestPostDate = new Date().toISOString().split('T')[0];

			const subItems = await fs.readdir(catFolder, { withFileTypes: true });

			for (const sub of subItems) {
				if (!sub.isDirectory()) continue;

				const mdxPath = path.join(catFolder, sub.name, 'page.mdx');
				const exists = await fs.stat(mdxPath).catch(() => false);
				if (!exists) continue;

				postCount++;

				let postDate = '1900-01-01';

				try {
					const text = await fs.readFile(mdxPath, 'utf-8');
					const match = text.match(/export const metadata\s*=\s*({[\s\S]*?});/);
					if (match) {
						const fnBody = `return ${match[1].trim()}`;
						const meta = new Function(fnBody)();
						if (meta.date && typeof meta.date === 'string') {
							postDate = meta.date;
						}
					}
				} catch {
					// silent
				}

				if (postDate === '1900-01-01') {
					const stats = await fs.stat(mdxPath);
					postDate = stats.birthtime.toISOString().split('T')[0];
				}

				if (postDate > latestPostDate) latestPostDate = postDate;
				if (postDate < earliestPostDate) earliestPostDate = postDate;
			}

			categories.push({
				slug,
				title: item.title || entry.name.replace(/-/g, ' '),
				description: item.description || '',
				date: item.date || earliestPostDate,
				path: `${BLOG_URL_PREFIX}/${entry.name}`,
				url: item.url,
				urlType: item.urlType,
				emoji: item.emoji || DEFAULT_EMOJI,
				pinned: item.pinned === true,
				featured: item.featured === true,
				tags: Array.isArray(item.tags) ? item.tags : [],
				posts: postCount,
				latest: latestPostDate,
			});
		}
	}

	categories.sort((a, b) => b.posts - a.posts);

	const code = `// AUTO-GENERATED by build-categories-meta.ts â€” do not edit
// Generated: ${new Date().toISOString()}

import type { CategoryMeta } from '@/next-blog/types/blog';

export const categoriesMeta: CategoryMeta[] = ${JSON.stringify(categories, null, 2)};
`;

	await fs.writeFile(OUTPUT, code, 'utf-8');

	console.log(`Updated: ${OUTPUT}`);
	console.log(`Total categories: ${categories.length}`);
}

run().catch(err => {
	console.error('Build failed:', err);
	process.exit(1);
});