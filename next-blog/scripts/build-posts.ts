// scripts/build-posts-meta.ts
import fs from 'node:fs/promises';
import path from 'node:path';
import { marked } from 'marked';

const BLOG_ROOT = path.join(process.cwd(), '/blog');

// â”€â”€ CONFIGURABLE PART â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BLOG_URL_PREFIX = '/blog';
const META_OUTPUT_DIR = path.join(process.cwd(), 'next-blog/meta');
const OUTPUT_FILE = path.join(META_OUTPUT_DIR, 'posts-meta.ts');
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const DEFAULT_EMOJI = 'ğŸ“';
const EXCERPT_MAX_PLAIN_CHARS = 400;

interface PostMeta {
	slug: string;
	title: string;
	description: string;
	date: string;
	path: string;
	category: string;
	url?: string;
	urlType?: string;
	emoji: string;
	pinned: boolean;
	featured: boolean;
	expanded: boolean;
	tags: string[];
	excerpt: string;
	long: boolean;
}

async function run() {
	await fs.mkdir(META_OUTPUT_DIR, { recursive: true });

	const posts: PostMeta[] = [];

	const categories = await fs.readdir(BLOG_ROOT, { withFileTypes: true });

	for (const cat of categories) {
		if (!cat.isDirectory() || cat.name.startsWith('(') || cat.name.startsWith('[') || cat.name === 'meta') {
			continue;
		}

		const catPath = path.join(BLOG_ROOT, cat.name);
		const items = await fs.readdir(catPath, { withFileTypes: true });

		for (const item of items) {
			if (!item.isDirectory()) continue;

			const mdxPath = path.join(catPath, item.name, 'page.mdx');

			let stat;
			try {
				stat = await fs.stat(mdxPath);
				if (!stat.isFile()) continue;
			} catch {
				continue;
			}

			const text = await fs.readFile(mdxPath, 'utf-8');

			let meta: Record<string, any> = {};

			const m = text.match(/export const metadata\s*=\s*({[\s\S]*?});/);
			if (m) {
				try {
					const fnBody = `return ${m[1].trim()}`;
					meta = new Function(fnBody)();
				} catch (err) {
					console.warn(`Metadata parse error in ${cat.name}/${item.name}:`, (err as Error).message);
				}
			}

			const bodyStart = text.indexOf('}', text.indexOf('metadata')) + 1 || 0;
			let body = text.slice(bodyStart).trim();

			const fullHtml = await marked.parse(body);

			const plainText = fullHtml.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();

			let excerpt = '';
			let isLong = false;

			if (plainText.length > EXCERPT_MAX_PLAIN_CHARS) {
				isLong = true;

				let cutAt = EXCERPT_MAX_PLAIN_CHARS;
				const sentenceEnd = plainText.lastIndexOf('.', cutAt);
				if (sentenceEnd > 100) cutAt = sentenceEnd + 1;

				const approxHtmlPos = Math.floor((cutAt / plainText.length) * fullHtml.length);
				let htmlCut = fullHtml.lastIndexOf('.', approxHtmlPos);
				if (htmlCut === -1) htmlCut = fullHtml.lastIndexOf('\n', approxHtmlPos);
				if (htmlCut > 100) htmlCut += 1;
				else htmlCut = approxHtmlPos;

				excerpt = fullHtml.slice(0, htmlCut).trim() + '...';
			} else {
				excerpt = fullHtml;
			}
			excerpt = excerpt.slice(10)

			const slug = `${cat.name}/${item.name}`;
			const fullPath = `${BLOG_URL_PREFIX}/${slug}`;

			posts.push({
				slug,
				title: meta.title || item.name.replace(/-/g, ' '),
				description: meta.description || body.slice(0, 160) + (body.length > 160 ? 'â€¦' : ''),
				date: meta.date || stat.birthtime.toISOString().split('T')[0],
				path: fullPath,
				category: cat.name,
				url: meta.url,
				urlType: meta.urlType,
				emoji: meta.emoji || DEFAULT_EMOJI,
				pinned: meta.pinned === true,
				featured: meta.featured === true,
				expanded: meta.expanded === true,
				tags: Array.isArray(meta.tags) ? meta.tags : [],
				excerpt,
				long: isLong,
			});
		}
	}

	posts.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

	const code = `// AUTO-GENERATED by build-posts-meta.ts â€” do not edit
// Generated: ${new Date().toISOString()}

import type { PostMeta } from '@/next-blog/types/blog';

export const postsMeta: PostMeta[] = ${JSON.stringify(posts, null, 2)};
`;

	await fs.writeFile(OUTPUT_FILE, code, 'utf-8');

	console.log(`Updated: ${OUTPUT_FILE}`);
	console.log(`Total posts: ${posts.length}`);
}

run().catch(err => {
	console.error('Build failed:', err);
	process.exit(1);
});